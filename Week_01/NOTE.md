学习笔记

# 复杂度分析

表示方法：大O表示法，T(n) = O(f(n))

常用的7种时间复杂度：

> O(1): Constant Complexity 常数复杂度
>
> O(log n): Logarithmic Complexity 对数复杂度
>
> O(n): Linear Complexity 线性时间复杂度
>
> O(n^2): N square Complexity 平⽅
>
> O(n^3): N square Complexity ⽴⽅
>
> O(2^n): Exponential Growth 指数
>
> O(n!): Factorial 阶乘

如何分析一段代码的时间复杂度：

极客时间训练营和王争老师的专栏这部分类似

时间复杂度可以简单理解为一段代码的执行次数

1. 只关注代码执行次数最多的的一段：循环，嵌套，递归等，刨去一些常数级别计算的代码。
2. 加法法则，和1类似， 总复杂度等于量级最大的那段代码的复杂度 ，如O(n^2) + O(n^3)即可以定义为O(n^3);另外如果一段代码执行了已知固定的次数，即使是1000,10000，那么它也只能算做常数，跟n的规模无关，当n无限大时就可以忽略。
3. 乘法法则，嵌套代码等于内外嵌套部分各自的复杂度相乘，比如双重循环n*(n - 1)，即算作O(n^2)
4. 特殊的时间复杂度
   1. 对数复杂度： O(logn)，一般出现在对数变化的算法上，比如二分查找，对数2增长(减少)。举个例子 

```java
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

    2. 指数复杂度：O(k^n)，一般出现在递归算法中，比如斐波拉契函数的递归形式。它的递归树每层是上一层的2倍，因此是O(2^N)

总结：时间复杂度越大在n越大的时候执行效率会变得非常低效。

有时候代码并不是像循环n次这样固定执行n遍的，代码里混合了其他分支语句。

最好时间复杂度

最坏时间复杂度

平均时间复杂度：需要用到一定简单的统计公式

均摊时间复杂度：一种特殊的平均时间复杂度。



# 数组

数组最大的特点是内存连续，支持随机访问，缺点是插入，删除，扩容需要额外的操作。

数组的特点和用法基本大家都很熟悉，

值得一提的是其内存连续的寻址公式以及索引为0开始的原因。

```java

a[k]_address = base_address + k * type_size
```

base_address：首地址

寻址公式也是数组的索引为什么从0开始的原因。

 但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为： 

```jav

a[k]_address = base_address + (k-1)*type_size
```

在内存中会多一次减法运算，对于数组这种底层的通用操作，需要尽量的快速高效。因此索引从0开始。



## 数组相关的算法题总结

从第一周接触算法后开始，每道题都需要多想几种解法，最开始如果不知道比较优秀的解法，大多数都可以使用暴力求解先解决。

- 移动零： https://leetcode-cn.com/problems/move-zeroes/ 
  - 双指针：学习到了双指针的一种形式，慢指针保持最新的非零数需要插入的索引，快指针一直往下遍历，当遍历到非零数就插入慢指针位置，如果快指针!=慢指针，当前快指针赋值0，之后慢指针自增1，遍历完后慢指针后面的数自然全为0；
- 盛水最多的容器： https://leetcode-cn.com/problems/container-with-most-water/ 
  - 双指针：学习到了另一种双指针形式，双指针逼近，这种形式一般将指针放置到数据left和right两个地方。通过left和right两个指针互相比较，通过一定条件判断left往右移动还是right往左移动，不断比较移动后的max值，如有变化就更新，这样，当条件不满足left<right时，比较完成，得出最优解max。
- 三数之和： https://leetcode-cn.com/problems/3sum/ 
  - 双指针：另一种双指针降低时间复杂度的形式，是另一种形式的双指针逼近。暴力求解三数之和肉眼可见的三重循环O(n^3),利用双指针一般都可以降低一重时间复杂度。
    - 由于涉及到去重等操作，一般这类双指针逼近需要有序作为前提，因此用Arrays.sort默认升序排序
    - 核心思想是，遍历排序数组，遍历的数组[i]右侧作为双指针区域，根据判断条件不断逼近。
    - 在这道题的难点在于很多去重的边界条件。
  - map 存值法
    - i + j + k = 0  相当于 i + j = -k，-k作为target目标，遍历数组将每个数的负数作为key，index作为value存入map中。
    - 二重循环遍历数组，找出存在i + j的key，那么说明存在值。
    - 也需要去重判断。

# 链表

- 了解到链表遍历的方式：

```java
while(ListNode != null){
	listNode = listNode.next;
}
```

- 链表需要熟悉其常用操作方式，特别是其前驱指针以及后继指针的操作。目前还不太熟练。

