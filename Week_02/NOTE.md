学习笔记

# hash表、映射、Set

哈希table的初始大小默认设置为16，为2的次幂数。后面在扩容时，都是以2的倍数来扩容。为什么非要将哈希table的大小控制为2的次幂数？

**原因1**：降低发生碰撞的概率，使散列更均匀。根据key的hash值计算bucket的下标位置时，使用“与”运算公式：h & (length-1)，当哈希表长度为2的次幂时，等同于使用表长度对hash值取模（不信大家可以自己演算一下），散列更均匀；不使用取模的原因是取模算法性能相对较低，涉及除法运算。
**原因2**：表的长度为2的次幂，那么(length-1)的二进制最后一位一定是1，在对hash值做“与”运算时，最后一位就可能为1，也可能为0，换句话说，取模的结果既有偶数，又有奇数。设想若(length-1)为偶数，那么“与”运算后的值只能是0，奇数下标的bucket就永远散列不到，会浪费一半的空间。

## tips

- 养成收藏精选代码的习惯

>  https://shimo.im/docs/R6g9WJV89QkHrDhr/read 

# 树、二叉树、二叉搜索树

# 树

Linked List 是特殊化的 Tree 

Tree 是特殊化的 Graph

树一旦形成有环那么就是图，不再是树。

定义：

- 根结点  没有父节点的节点叫作根节点 
- 父节点
- 子节点
- 兄弟结点
- 叶子结点（叶结点）

# 二叉树

每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。

二叉树遍历 Pre-order/In-order/Post-order 

1.前序（Pre-order）：根-左-右 

2.中序（In-order）：左-根-右 

3.后序（Post-order）：左-右-根

## 如何存储二叉树

1.  链式存储法 

2.  基于数组的顺序存储法 

   > 根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推



# 二叉搜索树，

也称二叉搜索树、有序二叉树（Ordered Binary Tree）排序二叉树（Sorted Binary Tree）

是指一棵空树或者具有下列性质的 二叉树：  

1. 左子树上所有结点的值均小于它的根结点的值；  

2. 右子树上所有结点的值均大于它的根结点的值；  

3. 以此类推：左、右子树也分别为二叉查找树。 （这就是 重复性！） 
4. 中序遍历二叉搜索树是**升序排列**

# 堆

堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法，但是工程上用得更多的是快排。

分为大顶堆和小顶堆

java的工程实现是PriorityQueue，可以直接使用。

堆有很多种实现，最常见和简单的是二叉堆，不过其效率并不是最优。

- 堆的实现代码：[ https://shimo.im/docs/GpwwDq66kC9RC3PX/](https://shimo.im/docs/GpwwDq66kC9RC3PX/)

常用于解决top k问题。